# goroutine-pool

根据线程池原理设计 goroutine 池.

## 如何配置线程

- 线程池肯定是不是越大越好
- IO 密集型任务：由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 * 2
- CPU 密集型任务（大量复杂的运算）应当分配较少的线程，比如 CPU 个数相当的大小
- 最好的方式还是根据实际情况测试得出最佳配置

## 优雅的关闭线程池

- `shutdown()` 执行后停止接受新任务，会把队列的任务执行完毕。
- `shutdownNow()` 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop

## 其他

- 添加任务其实是一个事件, 可以控制创建协程

如果协程和任务队列分离, 也就是说直接向任务队列中添加任务, 而一开始就创建一些数量的协程,
那么这种情况下, 任务数量变化时, 那些协程只能感知到 "获取不到任务", 而无法感知 "任务过多" 需要创建新的协程的情况.
当然可以根据任务数量状态来控制协程数量, 但是这样像是一种间接方法.

所以, 在添加新任务时总是要检查当前的协程数, 并根据配置合理创建协程.

- 为什么在 `newWorker()` 时就绑定一个任务?

如果判断此时需要创建新 worker (没到达 min 限制时), 在创建一个 worker 后将新任务放到任务队列时,
该 worker 应该先去争抢到任务队列的锁后才能获取到任务, 感觉慢一些.

# 参考

- [如何优雅的使用和理解线程池](https://mp.weixin.qq.com/s?__biz=MzIyMzgyODkxMQ==&mid=2247483842&idx=1&sn=af7514a1e132ba84075d5ddc2f1c6b0b&chksm=e8190f02df6e8614f13ec04cee11f035fe23a29cd9c682ef18cbe52716c90d84f9581815f054&scene=21#wechat_redirect)